module.exports = {
  /**
   * Share an array of values. Each sender may have an array of different length. This is handled by the lengths parameter.
   * This function will reveal the lengths of the shared array.
   * If parties would like to keep the lengths of their arrays secret, they should agree on some "max" length apriori (either under MPC
   * or as part of the logistics of the computation), all their arrays should be padded to that length by using appropriate default/identity
   * values.
   * @param {jiff-instance} jiff - the jiff instance.
   * @param {Array} array - the array to be shared.
   * @param {null|number|object} lengths - the lengths of the arrays to be shared, has the following options:
   *                                       1. null: lengths are unknown, each sender will publicly reveal the lengths of its own array.
   *                                       2. number: all arrays are of this length
   *                                       3. object: { <sender_party_id>: length }: must specify the length of the array for each sender.
   * @param {number} [threshold=receivers_list.length] - the min number of parties needed to reconstruct the secret, defaults to all the receivers.
   * @param {Array} [receivers_list=all_parties] - array of party ids to share with, by default, this includes all parties.
   * @param {Array} [senders_list=all_parties] - array of party ids to receive from, by default, this includes all parties.
   * @param {number} [Zp=jiff.Zp] - the mod.
   * @param {string|number} [share_id=auto_gen()] - the base tag used to tag the messages sent by this share operation, every element of the array
   *                                   will get a unique id based on the concatenation of base_share_id and the index of the element.
   *                                   This tag is used so that parties distinguish messages belonging to this share operation from
   *                                   other share operations between the same parties (when the order of execution is not
   *                                   deterministic). An automatic id is generated by increasing a local counter, default
   *                                   ids suffice when all parties execute all sharing operations with the same senders
   *                                   and receivers in the same order.
   * @return {promise} if the calling party is a receiver then a promise to the shared arrays is returned, the promise will provide an object
   *                    formatted as follows: { <party_id>: [ <1st_share>, <2nd_share>, ..., <(lengths[party_id])th_share> ] }
   *                    where the party_ids are those of the senders.
   *                    if the calling party is not a receiver, then null is returned.
   */
  jiff_share_array: function (jiff, array, lengths, threshold, receivers_list, senders_list, Zp, share_id) {
    /*
     *console.log('array: ', array)
     */
    var skeletons = null;
    if (lengths != null) {
      // Check format of lengths
      if (lengths != null && typeof(lengths) !== 'number' && typeof(lengths) !== 'object') {
        throw new Error('share_array: unrecognized lengths');
      }

      // Get senders list for later checking
      if (senders_list == null) {
        senders_list = [];
        for (i = 1; i <= jiff.party_count; i++) {
          senders_list.push(i);
        }
      }

      // Generate skeletons from lengths
      skeletons = {};
      if (typeof(lengths) === 'number') {
        // All arrays are of the same length
        var skeleton = [];
        for (var i = 0; i < lengths; i++) {
          skeleton.push(null);
        }
        for (i = 0; i < senders_list.length; i++) {
          skeletons[senders_list[i]] = skeleton;
        }
      } else {
        // Lengths of the different arrays are all provided
        for (i = 0; i < senders_list.length; i++) {
          if (lengths[senders_list[i]] == null) {
            throw new Error('share_array: missing length');
          } else {
            skeletons[senders_list[i]] = [];
            for (var j = 0; j < lengths[senders_list[i]]; j++) {
              skeletons[senders_list[i]].push(null);
            }
          }
        }
      }
    }

    /* console.log('shareND parameters: ', array, skeletons, threshold, receivers_list,senders_list); */
    return jiff.share_ND_array(array, skeletons, threshold, receivers_list, senders_list, Zp, share_id);
  },

  /**
   * Share an array of values. Each sender may have an array of different length. This is handled by the lengths parameter.
   * This function will reveal the lengths of the shared array.
   * If parties would like to keep the lengths of their arrays secret, they should agree on some "max" length apriori (either under MPC
   * or as part of the logistics of the computation), all their arrays should be padded to that length by using appropriate default/identity
   * values.
   * @param {jiff-instance} jiff - the jiff instance.
   * @param {Array} array - the array to be shared.
   * @param {null|number|object} lengths - the lengths of the arrays to be shared. For this to work successfully, the
   *                                       same exact value must be used in the calling code for each party. Any missing
   *                                       lengths for a row will be automatically publicly revealed by this function.
   *                                       Must have the following format:
   *                                       1. null: lengths are unknown, each sender will publicly reveal the lengths of its own array.
   *                                       2. { rows: <number>, cols: <number>, 0: <number>, 1: <number>, ...}: all parties have arrays
   *                                          with the given number of rows and cols. In case of jagged 2D arrays, different rows
   *                                          can have a different number of cols specified by using <row_index>: <col_size>.
   *                                          rows is mandatory, cols and any other number matching a specific row are optional.
   *                                       3. { <sender_party_id>: <length_object> }: must specify the lengths for each party by using
   *                                          an object with the same format as 2. Must include every party.
   * @param {number} [threshold=receivers_list.length] - the min number of parties needed to reconstruct the secret, defaults to all the receivers.
   * @param {Array} [receivers_list=all_parties] - array of party ids to share with, by default, this includes all parties.
   * @param {Array} [senders_list=all_parties] - array of party ids to receive from, by default, this includes all parties.
   * @param {number} [Zp=jiff_instance.Zp] - the mod (if null then the default Zp for the instance is used).
   * @param {string|number} [share_id=auto_gen()] - the base tag used to tag the messages sent by this share operation, every element of the array
   *                                   will get a unique id based on the concatenation of base_share_id and the index of the element.
   *                                   This tag is used so that parties distinguish messages belonging to this share operation from
   *                                   other share operations between the same parties (when the order of execution is not
   *                                   deterministic). An automatic id is generated by increasing a local counter, default
   *                                   ids suffice when all parties execute all sharing operations with the same senders
   *                                   and receivers in the same order.
   * @returns {promise} if the calling party is a receiver then a promise to the shared arrays is returned, the promise will provide an object
   *                    formatted as follows: { <party_id>: [ [ <1st_row_shares> ], [<2nd_row_share> ], ..., [ <(lengths[party_id])th_row_shares> ] ] }
   *                    where the party_ids are those of the senders.
   *                    if the calling party is not a receiver, then null is returned.
   */
  jiff_share_2D_array: function (jiff, array, lengths, threshold, receivers_list, senders_list, Zp, share_id) {
    var i;

    // Check format of lengths
    if (lengths != null && typeof(lengths) !== 'object') {
      throw new Error('share_array: unrecognized lengths');
    }

    // Default values
    if (receivers_list == null) {
      receivers_list = [];
      for (i = 1; i <= jiff.party_count; i++) {
        receivers_list.push(i);
      }
    }
    if (senders_list == null) {
      senders_list = [];
      for (i = 1; i <= jiff.party_count; i++) {
        senders_list.push(i);
      }
    }

    var isReceiving = receivers_list.indexOf(jiff.id) > -1;
    if (senders_list.indexOf(jiff.id) === -1 && !isReceiving) {
      // This party is neither a sender nor a receiver, do nothing!
      return null;
    }

    // compute operation id
    receivers_list.sort(); // sort to get the same order
    senders_list.sort();
    if (share_id == null) {
      share_id = jiff.counters.gen_share_id(receivers_list, senders_list) + ':array:';
    }

    // wrap around result of share_array
    var lengths_deferred = new jiff.helpers.Deferred();
    var lengths_promise = lengths_deferred.promise;

    // figure out lengths by having each party emit their length publicly
    if (lengths == null) {
      lengths = {};
      var total = 0;
      if (senders_list.indexOf(jiff.id) > -1) {
        lengths[jiff.id] = array.length;

        // send the length of this party's array to all receivers
        jiff.emit(share_id + 'length', receivers_list, array.length.toString(10));
      }

      jiff.listen(share_id + 'length', function (sender, message) {
        lengths[sender] = { rows: parseInt(message, 10) };
        total++;
        if (total === senders_list.length) {
          jiff.remove_listener(share_id + 'length');
          lengths_deferred.resolve(lengths);
        }
      });
    } else if (typeof(lengths.rows) === 'number') {
      // All arrays are of the same length
      var l = lengths;
      lengths = {};
      for (i = 0; i < senders_list.length; i++) {
        lengths[senders_list[i]] = l;
      }

      lengths_deferred.resolve(lengths);
    } else {
      // Lengths of the different arrays are all provided
      for (i = 0; i < senders_list.length; i++) {
        if (lengths[senders_list[i]] == null || lengths[senders_list[i]].rows == null) {
          throw new Error('share_2D_array: missing rows length');
        }
      }

      lengths_deferred.resolve(lengths);
    }

    // Final results
    var share_array_deferred = new jiff.helpers.Deferred();
    var share_array_promise = share_array_deferred.promise;

    // lengths are now set, start sharing
    lengths_promise.then(function (lengths) {
      // compute the number of sharing rounds
      var max = 0;
      for (i = 0; i < senders_list.length; i++) {
        var l = lengths[senders_list[i]].rows;
        max = l > max ? l : max;
      }

      // share every round
      var promises = [];
      for (var r = 0; r < max; r++) {
        var round_senders = [];
        for (i = 0; i < senders_list.length; i++) {
          if (lengths[senders_list[i]].rows > r) {
            round_senders.push(senders_list[i]);
          }
        }

        var row_lengths = {};
        var empty = false;
        for (var p = 0; p < round_senders.length; p++) {
          var pid = round_senders[p];
          row_lengths[pid] = lengths[pid].cols;
          if (lengths[pid][r] != null) {
            row_lengths[pid] = lengths[pid][r];
          }
          if (row_lengths[pid] == null) {
            empty = true;
          }
        }

        var row = r < array.length ? array[r] : [];
        row_lengths = empty ? null : row_lengths;
        var round_results = jiff.share_array(row, row_lengths, threshold, receivers_list, round_senders, Zp, share_id + 'row' + r + ':');
        promises.push(round_results);
      }

      // Wait for every promises corresponding to every row
      return Promise.all(promises).then(function (intermediate_results) {
        // Store results here
        var results = {};
        if (isReceiving) {
          for (i = 0; i < senders_list.length; i++) {
            results[senders_list[i]] = [];
          }
        }

        for (i = 0; i < intermediate_results.length; i++) {
          var round = intermediate_results[i];
          for (var sender_id in round) {
            if (round.hasOwnProperty(sender_id)) {
              results[sender_id].push(round[sender_id]);
            }
          }
        }

        share_array_deferred.resolve(results);
      });
    });

    return isReceiving ? share_array_promise : null;
  },

  /**
   * Opens a bunch of secret shares.
   * @param {jiff-instance} jiff - the jiff instance.
   * @param {SecretShare[]} shares - an array containing this party's shares of the secrets to reconstruct.
   * @param {Array<number|string|Array>} [parties=all_parties] - an array with party ids of receiving parties.
   *                          This must be one of 3 cases:
   *                          1. null:                       open all shares to all parties.
   *                          2. array of numbers:           open all shares to all the parties specified in the array.
   *                          3. array of array of numbers:  open share with index i to the parties specified
   *                                                         in the nested array at parties[i]. if parties[i] was null,
   *                                                         then shares[i] will be opened to all parties.
   * @param {string|number|object} [op_ids=auto_gen()] - an optional mapping that specifies the ID/Tag associated with each
   *                                        open message sent. Since open_array involves sending many messages per party,
   *                                        this parameter only specifies the BASE OPERATION ID. Each message sent will
   *                                        have this base id attached to it concatenated to a counter.
   *                                        If this is an object, then it should map an id of a receiving parties
   *                                        to the base op_id that should be used to tag the messages sent to that party.
   *                                        Parties left unmapped by this object will get an automatically generated id.
   *                                        If this is a number/string, then it will be used as the base id tagging all messages
   *                                        sent by this open to all parties.
   *                                        You can safely ignore this unless you have multiple opens each containing other opens.
   *                                        In that case, the order by which these opens are executed is not fully deterministic
   *                                        and depends on the order of arriving messages. In this case, use this parameter
   *                                        with every nested_open, to ensure ids are unique and define a total ordering on
   *                                        the execution of the opens (check implementation of slt for an example).
   * @returns {promise} a (JQuery) promise to ALL the open values of the secret, the promise will yield
   *                    a 2D array of values, each corresponding to the given share in the shares parameter
   *                    at the same index. In the case where different values are opened to different parties, the order
   *                    of the values will be preserved, but not the indices, there will be no blanks in the resulting arrays,
   *                    the first share that is opened to this party will appear at index [0], even if it was not initially
   *                    at [0].
   * @throws error if some shares does not belong to the passed jiff instance.
   */
  jiff_open_array: function (jiff, shares, parties, op_ids) {
    // A base operation id is provided to use for all opens.
    if (typeof(op_ids) === 'string' || typeof(op_ids) === 'number') {
      var tmp = { s1: op_ids };
      for (i = 1; i <= jiff.party_count; i++) {
        tmp[i] = op_ids;
      }
      op_ids = tmp;
    }

    return jiff.open_ND_array(shares, parties, null, op_ids);
  },

  jiff_sanitize_array_params : function (jiff, receivers_list, senders_list, threshold, Zp, share_id) {
    [receivers_list, senders_list] = [receivers_list, senders_list].map(function (party_list) {
      if (party_list == null) {
        party_list = [];
        for (let i = 1; i <= jiff.party_count; i++) {
          party_list.push(i);
        }
      }
      jiff.helpers.sort_ids(party_list);  // sort to get the same order
      return party_list;
    });

    if (threshold == null) {
      threshold = receivers_list.length;
    } else if (threshold < 0) {
      threshold = 2;
    } else if (threshold > receivers_list.length) {
      threshold = receivers_list.length;
    }

    if (Zp == null) {
      Zp = jiff.Zp;
    }

    if (share_id == null) {  // Make a unique id for this array
      share_id = jiff.counters.gen_op_id2('share_array', receivers_list, senders_list);
    }

    return [receivers_list, senders_list, threshold, Zp, share_id];
  },

  jiff_share_from_skeleton : function () {
    throw new Error('Please first bind jiff.share_from_skeleton with valid sharing parameters.');
  },

  jiff_share_from_skeleton_unbound : function (jiff, that, sender, skeleton) {
    let shares = typeof(skeleton) === 'string' ? JSON.parse(skeleton) : skeleton;

    let promise = jiff.share_array_single_sender(shares, that.threshold, that.receivers_list, sender, that.Zp, that.share_id + ':p_id_' + sender);

    promise.then(function (sender, array) {
      that.deferreds[sender].resolve(array);
    }.bind(null, sender));
  },

  jiff_share_array_single_sender : function (jiff, secrets, threshold, receivers_list, sender, Zp, share_id) {
    if (secrets != null && secrets.length === 0) {
      return Promise.resolve([]);
    } else if (secrets != null && Array.isArray(secrets)) {
      var promised_array = [];
      for (var j = 0; j < secrets.length; j++) {
        promised_array.push(jiff.share_array_single_sender(secrets[j], threshold, receivers_list, sender, Zp, share_id + ':' + j));
      }

      var isReceiving = receivers_list.indexOf(jiff.id) > -1;

      if (isReceiving) {
        var deferred_array = new jiff.helpers.Deferred();
        Promise.all(promised_array).then(function (array) {
          deferred_array.resolve(array);
        });
      }

      return isReceiving ? deferred_array.promise : Promise.resolve({});
    } else {
      // Create and distribute the share - Note: Senders are reorganized in the final array.
      // The return value of jiff.share is an array, [sender: share], and we only need to return share by itself.
      return Promise.resolve(jiff.share(secrets, threshold, receivers_list, [sender], Zp, 'share:' + share_id)[sender]);
    }
  },

  jiff_skeleton_of : function (jiff, nd_array, replace = null) {
    if (!(typeof(nd_array.length) === 'undefined') || nd_array.length === 0) {
      var wiped_array = [];
      for (var k = 0; k < nd_array.length; k++) {
        wiped_array.push(jiff.skeleton_of(nd_array[k], replace));
      }
      return wiped_array;
    }
    return replace;
  },

  jiff_match_skeletons : function (jiff, skeletons, senders_list) {
    let keys = Object.keys(skeletons);
    if (keys.length === senders_list.length) {
      for (let i = 0; i < senders_list.length; i++) {
        if (!(keys[i] == senders_list[i])) {  // TODO: strict comparison
          console.log('senders: ', senders_list);
          console.log('skeleton keys', keys);
          throw new Error('Keys of parameter \'skeletons\' should be the same as the senders');
        }
      }
    } else {
      throw new Error('Invalid parameter \'skeletons\'');
    }
  },


  /**
   * Share an n-dimensional array of secrets
   * The arrays can be of different lengths and dimensions.
   * @method share_ND_array
   */
  jiff_share_ND_array_deferred : function (jiff, secrets, skeletons, threshold, receivers_list, senders_list, Zp, share_id) {
    parameters = [receivers_list, senders_list, threshold, Zp, share_id];
    [receivers_list, senders_list, threshold, Zp, share_id] = jiff.sanitize_array_params.apply(null, parameters);

    var isReceiving = receivers_list.indexOf(jiff.id) > -1;
    var isSending = senders_list.indexOf(jiff.id) > -1;
    if (!isSending && !isReceiving) {
      return null;  // This party is neither a sender nor a receiver, do nothing!
    }

    // Setup deferreds: required because we don't yet know how many shares to account for
    var final_deferreds = [];
    for (let i = 0; i < senders_list.length; i++) {
      let p_id = senders_list[i];
      final_deferreds[p_id] = new jiff.helpers.Deferred();
    }

    // var total = 0;
    // if (++total === senders_list.length) {
    //   jiff.remove_listener(share_id + 'skeleton');
    // }
    jiff.share_from_skeleton = jiff.share_from_skeleton_unbound.bind(null, {
      deferreds: final_deferreds,
      threshold: threshold,
      receivers_list: receivers_list,
      Zp: Zp, share_id: share_id
    });

    if (skeletons == null) {
      if (isSending) {  // Send the shape and lengths of this party's array to all receivers
        let skeleton = jiff.skeleton_of(secrets);  // All secrets are removed while maintaing the array's orginial structure.
        let skeleton_str = JSON.stringify(skeleton);  // serialize for emit
        jiff.emit(share_id + 'skeleton', receivers_list, skeleton_str);
        jiff.share_from_skeleton(jiff.id, secrets);  // Share the real values matching the emitted skeleton
      }
      if (isReceiving) {
        jiff.listen(share_id + 'skeleton', jiff.share_from_skeleton);  // Receive shares when dimensions are known
      }
    } else {
      senders_list = Array.from(senders_list);  // remove jiff helpers' internal properties
      jiff.match_skeletons(skeletons, senders_list);  // Saftey check array dimention presets
      for (i in senders_list) {  // Share each party's array
        let p_id = senders_list[i];
        let myself = p_id === jiff.id;
        let skeleton = skeletons[p_id];
        jiff.share_from_skeleton(p_id, myself ? secrets : skeleton);
      }
    }


    // Combine all promises and re-index final array map
    var final_deferred = new jiff.helpers.Deferred();
    var final_promise = isReceiving ? final_deferred.promise : Promise.resolve({});
    Promise.all((function () {
      var all_promises = [];
      for (let i = 0; i < senders_list.length; i++) {
        let p_id = senders_list[i]
        all_promises.push(final_deferreds[p_id].promise);
      }
      return all_promises;
    })()).then(function (array) {
      var shares = {};
      for (let i = 0; i < senders_list.length; i++) {
        let p_id = senders_list[i];
        shares[p_id] = array[i];
      }
      final_deferred.resolve(shares);
    });

    return final_promise;  // Return promise to map of secret-shared arrays
  },


  /**
   * Share an n-dimensional array of secrets
   * The arrays can be of different lengths and dimensions.
   * @method share_ND_array
   */
  jiff_share_ND_array_static : function (jiff, secrets, skeletons, threshold, receivers_list, senders_list, Zp, share_id) {
    parameters = [receivers_list, senders_list, threshold, Zp, share_id];
    [receivers_list, senders_list, threshold, Zp, share_id] = jiff.sanitize_array_params.apply(null, parameters);

    let shares = {};

    var isReceiving = receivers_list.indexOf(jiff.id) > -1;
    var isSending = senders_list.indexOf(jiff.id) > -1;
    if (isSending || isReceiving) {
      // Static version of jiff.share_from_skeleton
      function share_from_skeleton(sender, skeleton) {
        return (function share_recursive(__secrets, share_id) {
          if (__secrets != null && __secrets.length === 0) {
            return [];
          } else if (__secrets != null && Array.isArray(__secrets)) {
            var array = [];
            for (var j = 0; j < __secrets.length; j++) {
              array.push(share_recursive(__secrets[j], share_id + ':' + j));
            }
            return isReceiving ? array : {};
          } else {
            return jiff.share(__secrets, threshold, receivers_list, [sender], Zp, 'share:' + share_id)[sender];
          }
        })(skeleton, share_id + ':p_id_' + sender);
      }

      senders_list = Array.from(senders_list);  // remove jiff helpers' internal properties
      jiff.match_skeletons(skeletons, senders_list);  // Saftey check array dimention presets
      for (i in senders_list) {  // Share each party's array
        let p_id = senders_list[i];
        let skeleton = skeletons[p_id];
        shares[p_id] = share_from_skeleton(p_id, p_id === jiff.id ? secrets : skeleton);
      }
    }

    return isReceiving ? shares : {};  // Return promise to map of secret-shared arrays
  },


  /**
   * Share an n-dimensional array of secrets
   * The arrays can be of different lengths and dimensions.
   * @method share_ND_array
   */
  jiff_share_ND_array : function (jiff, secrets, skeletons, threshold, receivers_list, senders_list, Zp, share_id) {
    let share_ND_array = skeletons != null ? jiff.share_ND_array_static : jiff.share_ND_array_deferred;
    return share_ND_array(secrets, skeletons, threshold, receivers_list, senders_list, Zp, share_id);
  },
  /**
   * Opens an n-dimensional array of secret shares.
   * @method open_ND_array
   * @memberof jiff-instance
   * @instance
   * @param {SecretShare|SecretShare[]|SecretShare[][]|...} shares - an n-dimensional array containing this party's shares of the secrets to reconstruct.
   * @param {Array[]} [parties=all_parties] - an array with party ids (1 to n) of receiving parties.
   * @param {string|number|object} [op_ids=auto_gen()] - an optional ID/Tag associated with these open operations
   * @returns {promise} a (JQuery) promise to ALL the open values of the secret, the promise will yield
   *                    an n-dimensional array of values, each corresponding to the given share in the shares parameter
   *                    at the same index. In the case where different values are opened to different parties, the order
   *                    of the values will be preserved, but not the indices, there will be no blanks in the resulting arrays,
   *                    the first share that is opened to this party will appear at indices [0][0], even if it was not initially
   *                    at [0][0].
   * @throws error if some shares does not belong to the passed jiff instance.
   */
  jiff_open_ND_array : function (jiff, shares, receivers_list, senders_list, op_ids) {
    if (senders_list == null) {
      senders_list = [];
      for (var i = 1; i <= jiff.party_count; i++) {
        senders_list.push(i);
      }
      if (receivers_list == null) {
        receivers_list = Array.from(senders_list);
      }
    }
    let is_sending = senders_list.indexOf(jiff.id) > -1;

    // Compute operation id
    if (op_ids == null) {
      op_ids = jiff.counters.gen_op_id('open_ND_array', receivers_list.concat(senders_list));
    }

    var final_deferred = new jiff.helpers.Deferred();
    var final_promise = final_deferred.promise;
    var resolve_open = function (shares) {
      final_deferred.resolve((
        function __open_ND_array(shares, parties, op_ids) {
          if (typeof(shares.length) === 'undefined') {
            return jiff.internal_open(shares, parties, op_ids + ':open');
          } else if (shares.length === 0) {
            return Promise.resolve([]);
          } else {
            var promised_array = [];
            for (var i = 0; i < shares.length; i++) {
              promised_array.push(__open_ND_array(shares[i], parties, op_ids + ':' + i));
            }
            return Promise.all(promised_array);
          }
        }
      )(shares, receivers_list, op_ids));
    };

    if (is_sending) {
      // Must emit the skeleton for any parties that are not holders but are receiving the open
      var skeleton = (function __wipe(nd_array, replace) {
        if (!(typeof (nd_array.length) === 'undefined') || nd_array.length === 0) {
          var wiped_array = [];
          for (var k = 0; k < nd_array.length; k++) {
            wiped_array.push(__wipe(nd_array[k], replace));
          }
          return wiped_array;
        }
        return replace;
      })(shares, null);
      jiff.emit(op_ids + 'skeleton', receivers_list, JSON.stringify(skeleton));

      resolve_open(shares);
    } else {
      // Populate skeleton with imitation shares
      var revive_shares = function (skeleton) {
        const share = new jiff.SecretShare({}, senders_list, senders_list.length, jiff.Zp);
        return (function __wipe(nd_array, replace) {
          if (nd_array != null && !(typeof (nd_array.length) === 'undefined' && nd_array.length > 0)) {
            var wiped_array = [];
            for (var k = 0; k < nd_array.length; k++) {
              wiped_array.push(__wipe(nd_array[k], replace));
            }
            return wiped_array;
          }
          return replace;
        })(skeleton, share);
      }

      // If this party is not a sender, then the variable `shares` may be a skeleton
      if (shares != null) {
        // Use existing shares as skeleton to revive
        shares = revive_shares(shares);
        resolve_open(shares);
      } else {
        // Receive skeleton from senders
        jiff.listen(op_ids + 'skeleton',  function (sender, skeleton) {
          jiff.remove_listener(op_ids + 'skeleton');  // This doesn't seem to work

          if (typeof(skeleton) === 'string') {
            skeleton = JSON.parse(skeleton);
          }

          shares = revive_shares(skeleton);
          resolve_open(shares);

          // BUG FIX: manually block the listener from hearing anything again
          resolve_open = function (shares) { /*console.warn('resolve_open doublecalled');*/ };
        });
      }
    }

    return final_promise;
  },
  //TODO: documentation
  jiff_receive_open_ND_array : function (jiff, parties, threshold, Zp, op_id) {
    var final_deferred = new jiff.helpers.Deferred();
    if (Zp == null) {
      Zp = jiff.Zp;
    }
    if (op_id == null) {
      op_id = jiff.counters.gen_op_id('open_ND_array', parties);
    }

    // listen for shape/skeleton
    // for each spot, call jiff.receive_open()
    jiff.listen(op_id + 'skeleton',  function (sender, skeleton) {
      jiff.remove_listener(op_id + 'skeleton');
      if (typeof(skeleton) === 'string') {
        skeleton = JSON.parse(skeleton);
      }
      (function __open_ND_array(shares, parties, op_id) {
        if (shares === null) {
          return jiff.receive_open(parties, threshold, Zp, op_id + ':open');
        } else if (shares.length === 0) {
          return Promise.resolve([]);
        } else {
          var promised_array = [];
          for (var i = 0; i < shares.length; i++) {
            promised_array.push(__open_ND_array(shares[i], parties, op_id + ':' + i));
          }
          var deferred_array = new jiff.helpers.Deferred();
          Promise.all(promised_array).then(function (array) {
            deferred_array.resolve(array);
          });

          return deferred_array.promise;
        }
      })(skeleton, parties, op_id).then(function (opened) {
        final_deferred.resolve(opened);
      });
    });
    return final_deferred.promise;
    //return jiff.open_ND_array(jiff.secret_share(jiff, true, null, null, parties, (threshold == null ? parties.length : threshold), Zp), parties, op_ids);
  }

};
