module.exports = {
  /**
   * Share an array of values. Each sender may have an array of different length. This is handled by the lengths parameter.
   * This function will reveal the lengths of the shared array.
   * If parties would like to keep the lengths of their arrays secret, they should agree on some "max" length apriori (either under MPC
   * or as part of the logistics of the computation), all their arrays should be padded to that length by using appropriate default/identity
   * values.
   * @param {jiff-instance} jiff - the jiff instance.
   * @param {Array} array - the array to be shared.
   * @param {null|number|object} lengths - the lengths of the arrays to be shared, has the following options:
   *                                       1. null: lengths are unknown, each sender will publicly reveal the lengths of its own array.
   *                                       2. number: all arrays are of this length
   *                                       3. object: { <sender_party_id>: length }: must specify the length of the array for each sender.
   * @param {number} [threshold=receivers_list.length] - the min number of parties needed to reconstruct the secret, defaults to all the receivers.
   * @param {Array} [receivers_list=all_parties] - array of party ids to share with, by default, this includes all parties.
   * @param {Array} [senders_list=all_parties] - array of party ids to receive from, by default, this includes all parties.
   * @param {number} [Zp=jiff.Zp] - the mod.
   * @param {string|number} [share_id=auto_gen()] - the base tag used to tag the messages sent by this share operation, every element of the array
   *                                   will get a unique id based on the concatenation of base_share_id and the index of the element.
   *                                   This tag is used so that parties distinguish messages belonging to this share operation from
   *                                   other share operations between the same parties (when the order of execution is not
   *                                   deterministic). An automatic id is generated by increasing a local counter, default
   *                                   ids suffice when all parties execute all sharing operations with the same senders
   *                                   and receivers in the same order.
   * @return {promise} if the calling party is a receiver then a promise to the shared arrays is returned, the promise will provide an object
   *                    formatted as follows: { <party_id>: [ <1st_share>, <2nd_share>, ..., <(lengths[party_id])th_share> ] }
   *                    where the party_ids are those of the senders.
   *                    if the calling party is not a receiver, then null is returned.
   */
  jiff_share_array: function (jiff, array, lengths, threshold, receivers_list, senders_list, Zp, share_id) {
    /*
     *console.log('array: ', array)
     */
    var skeletons = null;
    if (lengths != null) {
      // Check format of lengths
      if (lengths != null && typeof(lengths) !== 'number' && typeof(lengths) !== 'object') {
        throw new Error('share_array: unrecognized lengths');
      }

      // Get senders list for later checking
      if (senders_list == null) {
        senders_list = [];
        for (i = 1; i <= jiff.party_count; i++) {
          senders_list.push(i);
        }
      }

      // Generate skeletons from lengths
      skeletons = {};
      if (typeof(lengths) === 'number') {
        // All arrays are of the same length
        var skeleton = [];
        for (var i = 0; i < lengths; i++) {
          skeleton.push(null);
        }
        for (i = 0; i < senders_list.length; i++) {
          skeletons[senders_list[i]] = skeleton;
        }
      } else {
        // Lengths of the different arrays are all provided
        for (i = 0; i < senders_list.length; i++) {
          if (lengths[senders_list[i]] == null) {
            throw new Error('share_array: missing length');
          } else {
            skeletons[senders_list[i]] = [];
            for (var j = 0; j < lengths[senders_list[i]]; j++) {
              skeletons[senders_list[i]].push(null);
            }
          }
        }
      }
    }

    console.log('shareND parameters: ', array, skeletons, threshold, receivers_list,senders_list);
    return jiff.share_ND_array(array, skeletons, threshold, receivers_list, senders_list, Zp, share_id);
  },

  /**
   * Share an array of values. Each sender may have an array of different length. This is handled by the lengths parameter.
   * This function will reveal the lengths of the shared array.
   * If parties would like to keep the lengths of their arrays secret, they should agree on some "max" length apriori (either under MPC
   * or as part of the logistics of the computation), all their arrays should be padded to that length by using appropriate default/identity
   * values.
   * @param {jiff-instance} jiff - the jiff instance.
   * @param {Array} array - the array to be shared.
   * @param {null|number|object} lengths - the lengths of the arrays to be shared. For this to work successfully, the
   *                                       same exact value must be used in the calling code for each party. Any missing
   *                                       lengths for a row will be automatically publicly revealed by this function.
   *                                       Must have the following format:
   *                                       1. null: lengths are unknown, each sender will publicly reveal the lengths of its own array.
   *                                       2. { rows: <number>, cols: <number>, 0: <number>, 1: <number>, ...}: all parties have arrays
   *                                          with the given number of rows and cols. In case of jagged 2D arrays, different rows
   *                                          can have a different number of cols specified by using <row_index>: <col_size>.
   *                                          rows is mandatory, cols and any other number matching a specific row are optional.
   *                                       3. { <sender_party_id>: <length_object> }: must specify the lengths for each party by using
   *                                          an object with the same format as 2. Must include every party.
   * @param {number} [threshold=receivers_list.length] - the min number of parties needed to reconstruct the secret, defaults to all the receivers.
   * @param {Array} [receivers_list=all_parties] - array of party ids to share with, by default, this includes all parties.
   * @param {Array} [senders_list=all_parties] - array of party ids to receive from, by default, this includes all parties.
   * @param {number} [Zp=jiff_instance.Zp] - the mod (if null then the default Zp for the instance is used).
   * @param {string|number} [share_id=auto_gen()] - the base tag used to tag the messages sent by this share operation, every element of the array
   *                                   will get a unique id based on the concatenation of base_share_id and the index of the element.
   *                                   This tag is used so that parties distinguish messages belonging to this share operation from
   *                                   other share operations between the same parties (when the order of execution is not
   *                                   deterministic). An automatic id is generated by increasing a local counter, default
   *                                   ids suffice when all parties execute all sharing operations with the same senders
   *                                   and receivers in the same order.
   * @returns {promise} if the calling party is a receiver then a promise to the shared arrays is returned, the promise will provide an object
   *                    formatted as follows: { <party_id>: [ [ <1st_row_shares> ], [<2nd_row_share> ], ..., [ <(lengths[party_id])th_row_shares> ] ] }
   *                    where the party_ids are those of the senders.
   *                    if the calling party is not a receiver, then null is returned.
   */
  jiff_share_2D_array: function (jiff, array, lengths, threshold, receivers_list, senders_list, Zp, share_id) {
    var i;

    // Check format of lengths
    if (lengths != null && typeof(lengths) !== 'object') {
      throw new Error('share_array: unrecognized lengths');
    }

    // Default values
    if (receivers_list == null) {
      receivers_list = [];
      for (i = 1; i <= jiff.party_count; i++) {
        receivers_list.push(i);
      }
    }
    if (senders_list == null) {
      senders_list = [];
      for (i = 1; i <= jiff.party_count; i++) {
        senders_list.push(i);
      }
    }

    var isReceiving = receivers_list.indexOf(jiff.id) > -1;
    if (senders_list.indexOf(jiff.id) === -1 && !isReceiving) {
      // This party is neither a sender nor a receiver, do nothing!
      return null;
    }

    // compute operation id
    receivers_list.sort(); // sort to get the same order
    senders_list.sort();
    if (share_id == null) {
      share_id = jiff.counters.gen_share_id(receivers_list, senders_list) + ':array:';
    }

    // wrap around result of share_array
    var lengths_deferred = new jiff.helpers.Deferred();
    var lengths_promise = lengths_deferred.promise;

    // figure out lengths by having each party emit their length publicly
    if (lengths == null) {
      lengths = {};
      var total = 0;
      if (senders_list.indexOf(jiff.id) > -1) {
        lengths[jiff.id] = array.length;

        // send the length of this party's array to all receivers
        jiff.emit(share_id + 'length', receivers_list, array.length.toString(10));
      }

      jiff.listen(share_id + 'length', function (sender, message) {
        lengths[sender] = { rows: parseInt(message, 10) };
        total++;
        if (total === senders_list.length) {
          jiff.remove_listener(share_id + 'length');
          lengths_deferred.resolve(lengths);
        }
      });
    } else if (typeof(lengths.rows) === 'number') {
      // All arrays are of the same length
      var l = lengths;
      lengths = {};
      for (i = 0; i < senders_list.length; i++) {
        lengths[senders_list[i]] = l;
      }

      lengths_deferred.resolve(lengths);
    } else {
      // Lengths of the different arrays are all provided
      for (i = 0; i < senders_list.length; i++) {
        if (lengths[senders_list[i]] == null || lengths[senders_list[i]].rows == null) {
          throw new Error('share_2D_array: missing rows length');
        }
      }

      lengths_deferred.resolve(lengths);
    }

    // Final results
    var share_array_deferred = new jiff.helpers.Deferred();
    var share_array_promise = share_array_deferred.promise;

    // lengths are now set, start sharing
    lengths_promise.then(function (lengths) {
      // compute the number of sharing rounds
      var max = 0;
      for (i = 0; i < senders_list.length; i++) {
        var l = lengths[senders_list[i]].rows;
        max = l > max ? l : max;
      }

      // share every round
      var promises = [];
      for (var r = 0; r < max; r++) {
        var round_senders = [];
        for (i = 0; i < senders_list.length; i++) {
          if (lengths[senders_list[i]].rows > r) {
            round_senders.push(senders_list[i]);
          }
        }

        var row_lengths = {};
        var empty = false;
        for (var p = 0; p < round_senders.length; p++) {
          var pid = round_senders[p];
          row_lengths[pid] = lengths[pid].cols;
          if (lengths[pid][r] != null) {
            row_lengths[pid] = lengths[pid][r];
          }
          if (row_lengths[pid] == null) {
            empty = true;
          }
        }

        var row = r < array.length ? array[r] : [];
        row_lengths = empty ? null : row_lengths;
        var round_results = jiff.share_array(row, row_lengths, threshold, receivers_list, round_senders, Zp, share_id + 'row' + r + ':');
        promises.push(round_results);
      }

      // Wait for every promises corresponding to every row
      return Promise.all(promises).then(function (intermediate_results) {
        // Store results here
        var results = {};
        if (isReceiving) {
          for (i = 0; i < senders_list.length; i++) {
            results[senders_list[i]] = [];
          }
        }

        for (i = 0; i < intermediate_results.length; i++) {
          var round = intermediate_results[i];
          for (var sender_id in round) {
            if (round.hasOwnProperty(sender_id)) {
              results[sender_id].push(round[sender_id]);
            }
          }
        }

        share_array_deferred.resolve(results);
      });
    });

    return isReceiving ? share_array_promise : null;
  },

  /**
   * Opens a bunch of secret shares.
   * @param {jiff-instance} jiff - the jiff instance.
   * @param {SecretShare[]} shares - an array containing this party's shares of the secrets to reconstruct.
   * @param {Array<number|string|Array>} [parties=all_parties] - an array with party ids of receiving parties.
   *                          This must be one of 3 cases:
   *                          1. null:                       open all shares to all parties.
   *                          2. array of numbers:           open all shares to all the parties specified in the array.
   *                          3. array of array of numbers:  open share with index i to the parties specified
   *                                                         in the nested array at parties[i]. if parties[i] was null,
   *                                                         then shares[i] will be opened to all parties.
   * @param {string|number|object} [op_ids=auto_gen()] - an optional mapping that specifies the ID/Tag associated with each
   *                                        open message sent. Since open_array involves sending many messages per party,
   *                                        this parameter only specifies the BASE OPERATION ID. Each message sent will
   *                                        have this base id attached to it concatenated to a counter.
   *                                        If this is an object, then it should map an id of a receiving parties
   *                                        to the base op_id that should be used to tag the messages sent to that party.
   *                                        Parties left unmapped by this object will get an automatically generated id.
   *                                        If this is a number/string, then it will be used as the base id tagging all messages
   *                                        sent by this open to all parties.
   *                                        You can safely ignore this unless you have multiple opens each containing other opens.
   *                                        In that case, the order by which these opens are executed is not fully deterministic
   *                                        and depends on the order of arriving messages. In this case, use this parameter
   *                                        with every nested_open, to ensure ids are unique and define a total ordering on
   *                                        the execution of the opens (check implementation of slt for an example).
   * @returns {promise} a (JQuery) promise to ALL the open values of the secret, the promise will yield
   *                    a 2D array of values, each corresponding to the given share in the shares parameter
   *                    at the same index. In the case where different values are opened to different parties, the order
   *                    of the values will be preserved, but not the indices, there will be no blanks in the resulting arrays,
   *                    the first share that is opened to this party will appear at index [0], even if it was not initially
   *                    at [0].
   * @throws error if some shares does not belong to the passed jiff instance.
   */
  jiff_open_array: function (jiff, shares, parties, op_ids) {
    var parties_nested_arrays = (parties != null && (parties[0] == null || (typeof(parties[0]) !== 'number' && typeof(parties[0]) !== 'string')));

    // Compute operation ids (one for each party that will receive a result
    if (op_ids == null) {
      op_ids = {};
    }

    // A base operation id is provided to use for all opens.
    if (typeof(op_ids) === 'string' || typeof(op_ids) === 'number') {
      var tmp = { s1: op_ids };
      for (i = 1; i <= jiff.party_count; i++) {
        tmp[i] = op_ids;
      }
      op_ids = tmp;
    }

    var promises = [];
    for (var i = 0; i < shares.length; i++) {
      var party = parties_nested_arrays ? parties[i] : parties;

      var ids = {};
      for (var p in op_ids) {
        if (op_ids.hasOwnProperty(p) && op_ids[p] != null) {
          ids[p] = op_ids[p] + ':' + i;
        }
      }

      var promise = jiff.open(shares[i], party, ids);
      if (promise != null) {
        promises.push(promise);
      }
    }

    if (promises.length === 0) {
      return null;
    }

    console.log('open_array', {
      shares: shares,
      parties: parties,
      parties_nested_arrays: parties_nested_arrays,
      op_ids: op_ids,
      ids: ids
    });

    return Promise.all(promises);
  },

  /**
   * Share an n-dimensional array of secrets
   * The arrays can be of different lengths and dimensions.
   * @method share_ND_array
   * @memberof jiff-instance
   * @instance
   * @param {Array} secrets - the n-dimensional array of numbers to share (this party's input)
   * @param {object} [skeletons=null] - A map from party IDs to the expected shape of that party's input array (e.g. {'1': [[null, null], [null, null]]}.
   *                                    This parameter should only be set if the shapes of each party's input is known in advance.
   *                                    If set, this will skip the listening step and share right away
   *                                    using the structure specified for each party.
   * @param {number} [threshold=receivers_list.length] - the minimum number of parties needed to reconstruct the secret, defaults to all the receivers.
   * @param {Array} [receivers_list=all_parties] - array of party ids to share with, by default, this includes all parties.
   * @param {Array} [senders_list=all_parties] - array of party ids to receive from, by default, this includes all parties.
   * @param {number} [Zp=jiff_instance.Zp] - the mod (if null then the default Zp for the instance is used).
   * @param {string|number} [share_id=auto_gen()] - the tag used to tag the messages sent by this share operation, this tag is used
   * @returns {promise} - a (JQuery) promise to a map (of size equal to the number of senders)
   *                      where the key is the party id (from 1 to n) and the value are each
   *                      an n-dimensional array of secret shares corresponding to the secrets
   *                      in the arrays passed by the senders
   */
  jiff_share_ND_array : function (jiff, secrets, skeletons, threshold, receivers_list, senders_list, Zp, share_id) {
    //TODO: move threshold to be consistent with other share_ function parameteres (i.e. after receivers/senders)
    var i, p_id;

    // Default values
    if (receivers_list == null) {
      receivers_list = [];
      for (i = 1; i <= jiff.party_count; i++) {
        receivers_list.push(i);
      }
    }
    if (senders_list == null) {
      senders_list = [];
      for (i = 1; i <= jiff.party_count; i++) {
        senders_list.push(i);
      }
    }
    if (threshold == null) {
      threshold = receivers_list.length;
    } else if (threshold < 0) {
      threshold = 2;
    } else if (threshold > receivers_list.length) {
      threshold = receivers_list.length;
    }
    if (Zp == null) {
      Zp = jiff.Zp;
    }

    var isReceiving = receivers_list.indexOf(jiff.id) > -1;
    var isSending = senders_list.indexOf(jiff.id) > -1;
    if (!isSending && !isReceiving) {
      return null;
    } // This party is neither a sender nor a receiver, do nothing!

    // compute operation id
    receivers_list.sort((x,y)=>(x-y)); // sort to get the same order
    senders_list.sort((x,y)=>(x-y));
    if (share_id == null) {
      share_id = jiff.counters.gen_op_id2('share_array', receivers_list, senders_list);
      console.log('gen_op_id2', 'share_array', receivers_list, senders_list);
    }
    console.log('share_id', share_id);

    // Setup deferreds
    // This is required, because we don't yet know how many shares to account for.
    var final_deferreds = [];
    for (i = 0; i < senders_list.length; i++) {
      p_id = senders_list[i];
      final_deferreds[p_id] = new jiff.helpers.Deferred();
    }

    //for (var p_id = senders_list[0]; p_id <= senders_list[senders_list.length-1]; p_id++) {
    //  final_deferreds[p_id] = new Deferred();
    //}

    // Recursive sharing sub-function
    var total = 0;
    let share_from_skeleton = function (sender, __skeleton) {
      if (++total === senders_list.length) {
        jiff.remove_listener(share_id + 'skeleton');
      }

      // Share the real values if you know them
      // else create the symbolic shares for receiving
      if (sender === jiff.id) {
        __skeleton = secrets;
      } else if (typeof(__skeleton) === 'string') {
        __skeleton = JSON.parse(__skeleton);
      }

      (function __share_ND_array(secrets, share_id) {
        if (secrets != null && secrets.length === 0) {
          return Promise.resolve([]);
        } else if (secrets != null && Array.isArray(secrets)) {
          var promised_array = [];
          for (var j = 0; j < secrets.length; j++) {
            promised_array.push(__share_ND_array(secrets[j], share_id + ':' + j));
          }

          if (isReceiving) {
            var deferred_array = new jiff.helpers.Deferred();
            Promise.all(promised_array).then(function (array) {
              deferred_array.resolve(array);
            });
          }

          return isReceiving ? deferred_array.promise : Promise.resolve({});
        } else {
          // Create and distribute the share - Note: Senders are reorganized in the final array.
          // The return value of jiff.share is an array, [sender: share], and we only need to return share by itself.
          console.log('threshold in share_ND: ', threshold)
          return Promise.resolve(jiff.share(secrets, threshold, receivers_list, [sender], Zp, 'share:' + share_id)[sender]);
        }
      })(__skeleton, share_id + ':p_id_' + sender).then(function (sender, array) {
        final_deferreds[sender].resolve(array);
      }.bind(null, sender));
    };

    if (skeletons == null) {
      // Send the shape and lengths of this party's array to all receivers
      if (isSending) {
        // All secrets are removed while maintaing the array's orginial structure.
        let skeleton = (function __wipe(nd_array, replace) {
          if (!(typeof(nd_array.length) === 'undefined') || nd_array.length === 0) {
            var wiped_array = [];
            for (var k = 0; k < nd_array.length; k++) {
              wiped_array.push(__wipe(nd_array[k], replace));
            }
            return wiped_array;
          }
          return replace;
        })(secrets, null);

        jiff.emit(share_id + 'skeleton', receivers_list, JSON.stringify(skeleton));
        share_from_skeleton(jiff.id, skeleton);
      }

      // Share when dimensions are known
      if (isReceiving) {
        jiff.listen(share_id + 'skeleton', share_from_skeleton);
      }
    } else {
      // Saftey check array dimention presets
      let keys = Object.keys(skeletons);
      if (keys.length === senders_list.length) {
        for (i = 0; i < senders_list.length; i++) {
          if (!(keys[i] == senders_list[i])) { //TODO either change format of senders, or (more likely) skeleton keys.
            // TODO: should be a strict comparison, maybe convert keys to numeric type
            console.log('senders: ', senders_list);
            console.log('skeleton keys', keys);
            throw new Error('Keys of parameter \'skeletons\' should be the same as the senders');
          }
        }
      } else {
        throw new Error('Invalid parameter \'skeletons\'');
      }

      // Share each party's array
      for (i in senders_list) {           // POTENTIAL BUG: what is this code? doesn't this seem unusually straightforward?
        let p_id = senders_list[i];
        share_from_skeleton(p_id, skeletons[p_id]);
      }
    }

    var all_promises = [];
    for (i = 0; i < senders_list.length; i++) {
      p_id = senders_list[i]
      all_promises.push(final_deferreds[p_id].promise);
    }

    // Combine all promises and re-index final array map
    var final_deferred = new jiff.helpers.Deferred();
    var final_promise = final_deferred.promise;
    Promise.all(all_promises).then(function (array) {
      var shares = {};
      for (var i = 0; i < senders_list.length; i++) {
        let p_id = senders_list[i];
        shares[p_id] = array[i];
      }
      final_deferred.resolve(shares);
    });

    console.log('jiff_share_ND_array', {
      secrets: secrets,
      skeletons: skeletons,
      threshold: threshold,
      receivers_list: receivers_list,
      senders_list: senders_list,
      Zp: Zp,
      share_id: share_id
    });

    // Return promise to map of secret-shared arrays
    return isReceiving ? final_promise : Promise.resolve({});
  },
  /**
   * Opens an n-dimensional array of secret shares.
   * @method open_ND_array
   * @memberof jiff-instance
   * @instance
   * @param {SecretShare|SecretShare[]|SecretShare[][]|...} shares - an n-dimensional array containing this party's shares of the secrets to reconstruct.
   * @param {Array[]} [parties=all_parties] - an array with party ids (1 to n) of receiving parties.
   * @param {string|number|object} [op_ids=auto_gen()] - an optional ID/Tag associated with these open operations
   * @returns {promise} a (JQuery) promise to ALL the open values of the secret, the promise will yield
   *                    an n-dimensional array of values, each corresponding to the given share in the shares parameter
   *                    at the same index. In the case where different values are opened to different parties, the order
   *                    of the values will be preserved, but not the indices, there will be no blanks in the resulting arrays,
   *                    the first share that is opened to this party will appear at indices [0][0], even if it was not initially
   *                    at [0][0].
   * @throws error if some shares does not belong to the passed jiff instance.
   */
  jiff_open_ND_array : function (jiff, shares, receivers_list, senders_list, op_ids) {
    if (senders_list == null) {
      senders_list = [];
      for (var i = 1; i <= jiff.party_count; i++) {
        senders_list.push(i);
      }
    }
    let is_sending = senders_list.indexOf(jiff.id) > -1;

    // Compute operation id
    if (op_ids == null) {
      op_ids = jiff.counters.gen_op_id('open_ND_array', receivers_list.concat(senders_list));
    }

    console.log('ndarray', receivers_list, senders_list, jiff.id, senders_list.length);

    var final_deferred = new jiff.helpers.Deferred();
    var final_promise = final_deferred.promise;
    var resolve_open = function (shares) {
      final_deferred.resolve((
        function __open_ND_array(shares, parties, op_ids) {
          if (typeof(shares.length) === 'undefined') {
            return jiff.internal_open(shares, parties, op_ids + ':open');
          } else if (shares.length === 0) {
            return Promise.resolve([]);
          } else {
            var promised_array = [];
            for (var i = 0; i < shares.length; i++) {
              promised_array.push(__open_ND_array(shares[i], parties, op_ids + ':' + i));
            }
            return Promise.all(promised_array);
          }
        }
      )(shares, receivers_list, op_ids));
    };

    if (is_sending) {
      // Must emit the skeleton for any parties that are not holders but are receiving the open
      var skeleton = (function __wipe(nd_array, replace) {
        if (!(typeof (nd_array.length) === 'undefined') || nd_array.length === 0) {
          var wiped_array = [];
          for (var k = 0; k < nd_array.length; k++) {
            wiped_array.push(__wipe(nd_array[k], replace));
          }
          return wiped_array;
        }
        return replace;
      })(shares, null);
      jiff.emit(op_ids + 'skeleton', receivers_list, JSON.stringify(skeleton));

      resolve_open(shares);
    } else {
      // Populate skeleton with imitation shares
      var revive_shares = function (skeleton) {
        const share = new jiff.SecretShare({}, senders_list, senders_list.length, jiff.Zp);
        return (function __wipe(nd_array, replace) {
          if (nd_array != null && !(typeof (nd_array.length) === 'undefined' && nd_array.length > 0)) {
            var wiped_array = [];
            for (var k = 0; k < nd_array.length; k++) {
              wiped_array.push(__wipe(nd_array[k], replace));
            }
            return wiped_array;
          }
          return replace;
        })(skeleton, share);
      }

      // If this party is not a sender, then the variable `shares` may be a skeleton
      if (shares != null) {
        // Use existing shares as skeleton to revive
        shares = revive_shares(shares);
        resolve_open(shares);
      } else {
        // Receive skeleton from senders
        jiff.listen(op_ids + 'skeleton',  function (sender, skeleton) {
          jiff.remove_listener(op_ids + 'skeleton');  // This doesn't seem to work

          if (typeof(skeleton) === 'string') {
            skeleton = JSON.parse(skeleton);
          }

          shares = revive_shares(skeleton);
          resolve_open(shares);

          // BUG FIX: manually block the listener from hearing anything again
          resolve_open = function (shares) { console.log('resolve_open doublecalled'); };
        });
      }
    }

    return final_promise;
  },
  //TODO: documentation
  jiff_receive_open_ND_array : function (jiff, parties, threshold, Zp, op_id) {
    var final_deferred = new jiff.helpers.Deferred();
    if (Zp == null) {
      Zp = jiff.Zp;
    }
    if (op_id == null) {
      op_id = jiff.counters.gen_op_id('open_ND_array', parties);
    }

    // listen for shape/skeleton
    // for each spot, call jiff.receive_open()
    jiff.listen(op_id + 'skeleton',  function (sender, skeleton) {
      jiff.remove_listener(op_id + 'skeleton');
      if (typeof(skeleton) === 'string') {
        skeleton = JSON.parse(skeleton);
      }
      (function __open_ND_array(shares, parties, op_id) {
        if (shares === null) {
          return jiff.receive_open(parties, threshold, Zp, op_id + ':open');
        } else if (shares.length === 0) {
          return Promise.resolve([]);
        } else {
          var promised_array = [];
          for (var i = 0; i < shares.length; i++) {
            promised_array.push(__open_ND_array(shares[i], parties, op_id + ':' + i));
          }
          var deferred_array = new jiff.helpers.Deferred();
          Promise.all(promised_array).then(function (array) {
            deferred_array.resolve(array);
          });

          return deferred_array.promise;
        }
      })(skeleton, parties, op_id).then(function (opened) {
        final_deferred.resolve(opened);
      });
    });
    return final_deferred.promise;
    //return jiff.open_ND_array(jiff.secret_share(jiff, true, null, null, parties, (threshold == null ? parties.length : threshold), Zp), parties, op_ids);
  }

};
